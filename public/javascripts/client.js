// Generated by CoffeeScript 1.4.0
(function() {
  var Camera, Engine, Input, Map, Player, onMovePlayer, onNewPlayer, onRemovePlayer, onSocketConnected, onSocketDisconnect, playerById, setEventHandlers;

  (function() {
    var hasPerformance, lastTime, max, rAF, startTime, vendors, x;
    lastTime = 0;
    vendors = ["ms", "moz", "webkit", "o"];
    hasPerformance = !!(window.performance && window.performance.now);
    x = 0;
    max = vendors.length;
    while (x < max && !window.requestAnimationFrame) {
      window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
      x += 1;
    }
    if (!window.requestAnimationFrame) {
      console.log("Polyfill");
      window.requestAnimationFrame = function(callback, element) {
        var currTime, id, timeToCall;
        currTime = new Date().getTime();
        timeToCall = Math.max(0, 16 - (currTime - lastTime));
        id = window.setTimeout(function() {
          return callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) {
        return clearTimeout(id);
      };
    }
    if (!hasPerformance) {
      console.log("performance not supported");
      rAF = window.requestAnimationFrame;
      startTime = new Date;
      return window.requestAnimationFrame = function(callback, element) {
        var wrapped;
        wrapped = function(timestamp) {
          var performanceTimestamp;
          performanceTimestamp = (timestamp < 1e12 ? timestamp : timestamp - startTime);
          return callback(performanceTimestamp);
        };
        return rAF(wrapped, element);
      };
    } else {
      return console.log("performance supported");
    }
  })();

  Input = function() {
    var i, that;
    that = this;
    this.keys = new Array();
    i = 0;
    while (i < 100) {
      this.keys[i] = false;
      i++;
    }
    this.update = function(e) {
      if (e.type === "keyup") {
        that.keys[e.which] = false;
      }
      if (e.type === "keydown") {
        that.keys[e.which] = true;
      }
    };
  };

  Player = function(startx, starty) {
    var that;
    that = this;
    this.id = 0;
    this.x = startx;
    this.y = starty;
    this.newX = this.x;
    this.newY = this.y;
    this.dx = 0;
    this.dy = 0;
    this.runSpeed = 0.23;
    this.jumpSpeed = 0.36;
    this.airSpeed = 0.01;
    this.gravity = 0.023;
    this.width = 30;
    this.height = 30;
    this.jumping = false;
    this.grounded = false;
    this.tick = function(delta) {
      this.grounded = Engine.map.entityGrounded(this);
      if (Engine.input.keys[37]) {
        this.dx = -0.23;
      } else if (Engine.input.keys[39]) {
        this.dx = 0.23;
      } else {
        this.dx = 0;
      }
      if (Engine.input.keys[65] && this.grounded) {
        this.grounded = false;
        this.jumping = true;
        this.dy -= this.jumpSpeed;
      } else {
        if (!Engine.input.keys[65]) {
          this.jumping = false;
        }
      }
      if (this.jumping) {
        this.dy -= this.airSpeed;
        if (this.dy > 0) {
          this.jumping = false;
        }
      }
      if (!this.grounded) {
        this.dy += this.gravity;
      }
      this.newX = this.dx * delta;
      this.newY = this.dy * delta;
    };
    this.render = function(camera) {
      Engine.context.fillStyle = "rgb(255,0,0)";
      Engine.context.beginPath();
      Engine.context.rect(-camera.x + this.x, -camera.y + this.y, this.width, this.height);
      Engine.context.closePath();
      Engine.context.fill();
      Engine.context.fillStyle = "blue";
      Engine.context.font = "bold 12px Arial";
      Engine.context.fillText(this.grounded, 5, 15);
      Engine.context.fillStyle = "blue";
      Engine.context.font = "bold 12px Arial";
      Engine.context.fillText(this.jumping, 5, 30);
    };
  };

  Map = function(map) {
    var that, x, y;
    that = this;
    this.player;
    this.tileSize = 40;
    this.height = map.length;
    this.width = map[0].length;
    this.tiles = new Array(this.width);
    this.entities = new Array();
    this.camera = new Camera(-(Engine.canvasWidth - this.tileSize * this.width) / 2, -(Engine.canvasHeight - this.tileSize * this.height) / 2);
    x = 0;
    while (x < this.width) {
      this.tiles[x] = new Array(this.height);
      y = 0;
      while (y < this.height) {
        if (map[y].charAt(x) === "#") {
          this.tiles[x][y] = 1;
        } else if (map[y].charAt(x) === "P") {
          this.player = new Player(x * this.tileSize, y * this.tileSize);
          this.entities.push(this.player);
        } else {
          this.tiles[x][y] = 0;
        }
        y++;
      }
      x++;
    }
    this.tick = function(delta) {
      var i;
      i = 0;
      while (i < this.entities.length) {
        this.entities[i].tick(delta);
        this.moveEntity(this.entities[i], this.entities[i].x + this.entities[i].newX, this.entities[i].y, 1);
        this.moveEntity(this.entities[i], this.entities[i].x, this.entities[i].y + this.entities[i].newY, 0);
        i++;
      }
    };
    this.moveEntity = function(entity, newX, newY, type) {
      var xe, xf, xs, xt, ye, yf, ys, yt;
      xf = Math.min(entity.x, newX);
      xt = Math.max(entity.x, newX) + entity.width - 1;
      yf = Math.min(entity.y, newY);
      yt = Math.max(entity.y, newY) + entity.height - 1;
      xs = Math.floor(xf / this.tileSize);
      xe = Math.floor(xt / this.tileSize);
      ys = Math.floor(yf / this.tileSize);
      ye = Math.floor(yt / this.tileSize);
      y = ys;
      while (y <= ye) {
        x = xs;
        while (x <= xe) {
          if (this.tiles[x][y] === 1) {
            if (type === 0) {
              if (entity.dy > 0) {
                entity.y = y * this.tileSize - entity.height;
                entity.grounded = true;
              } else {
                if (entity.dy < 0) {
                  entity.y = y * this.tileSize + this.tileSize;
                }
              }
              entity.dy = 0;
            } else if (type === 1) {
              if (entity.dx > 0) {
                entity.x = x * this.tileSize - entity.width;
              } else {
                if (entity.dx < 0) {
                  entity.x = x * this.tileSize + this.tileSize;
                }
              }
              entity.dx = 0;
            }
            return;
          } else {
            entity.x = newX;
            entity.y = newY;
          }
          x++;
        }
        y++;
      }
    };
    this.entityGrounded = function(entity) {
      var xe, xs, ye;
      xs = Math.floor(entity.x / this.tileSize);
      xe = Math.floor((entity.x + entity.width - 1) / this.tileSize);
      ye = Math.floor((entity.y + entity.height + 1) / this.tileSize);
      if (ye > this.height - 1) {
        return true;
      }
      x = xs;
      while (x <= xe) {
        if (this.tiles[x][ye] === 1) {
          return true;
        }
        x++;
      }
      return false;
    };
    this.render = function() {
      var i;
      Engine.context.fillStyle = "rgb(0,0,0)";
      y = 0;
      while (y < this.height) {
        x = 0;
        while (x < this.width) {
          if (this.tiles[x][y] === 1) {
            Engine.context.beginPath();
            Engine.context.rect(-this.camera.x + x * this.tileSize, -this.camera.y + y * this.tileSize, this.tileSize, this.tileSize);
            Engine.context.closePath();
            Engine.context.fill();
          }
          x++;
        }
        y++;
      }
      i = 0;
      while (i < this.entities.length) {
        this.entities[i].render(this.camera);
        i++;
      }
      i = 0;
      while (i < Engine.remotePlayers.length) {
        Engine.remotePlayers[i].render(this.camera);
        i++;
      }
    };
  };

  Camera = function(x, y) {
    this.x = x;
    this.y = y;
  };

  setEventHandlers = function() {
    Engine.socket.on("connect", onSocketConnected);
    Engine.socket.on("disconnect", onSocketDisconnect);
    Engine.socket.on("new player", onNewPlayer);
    Engine.socket.on("move player", onMovePlayer);
    Engine.socket.on("remove player", onRemovePlayer);
  };

  onSocketConnected = function() {
    console.log("Connected to socket server");
    Engine.socket.emit("new player", {
      x: Engine.map.player.x,
      y: Engine.map.player.y
    });
  };

  onSocketDisconnect = function() {
    console.log("Disconnected from socket server");
  };

  onNewPlayer = function(data) {
    var newPlayer;
    console.log("New player connected: " + data.id);
    newPlayer = new Player(data.x, data.y);
    newPlayer.id = data.id;
    Engine.remotePlayers.push(newPlayer);
  };

  onMovePlayer = function(data) {
    var movePlayer;
    movePlayer = playerById(data.id);
    if (!movePlayer) {
      console.log("Player not found: " + data.id);
      return;
    }
    movePlayer.x = data.x;
    movePlayer.y = data.y;
  };

  onRemovePlayer = function(data) {
    var removePlayer;
    removePlayer = playerById(data.id);
    if (!removePlayer) {
      console.log("Player not found: " + data.id);
      return;
    }
    Engine.remotePlayers.splice(Engine.remotePlayers.indexOf(removePlayer), 1);
  };

  playerById = function(id) {
    var i;
    i = void 0;
    i = 0;
    while (i < Engine.remotePlayers.length) {
      if (Engine.remotePlayers[i].id === id) {
        return Engine.remotePlayers[i];
      }
      i++;
    }
    false;
    return null;
  };

  Engine = (function() {

    function Engine() {}

    Engine.canvas = void 0;

    Engine.context = void 0;

    Engine.canvasWidth = void 0;

    Engine.canvasHeight = void 0;

    Engine.lastTime = 0;

    Engine.delta = 0;

    Engine.input = new Input();

    Engine.map = void 0;

    Engine.camera = void 0;

    Engine.deltaSum = 0;

    Engine.deltaAccum = 0;

    Engine.deltaAverage = 0;

    Engine.ticks = 0;

    Engine.frames = 0;

    Engine.tps = 0;

    Engine.fps = 0;

    Engine.frameTime = 1000 / 60;

    Engine.maxFrameTime = Math.round(Engine.frameTime * 3);

    Engine.remotePlayers = void 0;

    Engine.multiplayer = void 0;

    Engine.tick = function(delta) {
      Engine.ticks++;
      Engine.map.tick(delta);
      if (Engine.multiplayer) {
        Engine.socket.emit("move player", {
          x: Engine.map.player.x,
          y: Engine.map.player.y
        });
      }
    };

    Engine.render = function() {
      Engine.context.save();
      Engine.context.setTransform(1, 0, 0, 1, 0, 0);
      Engine.context.clearRect(0, 0, Engine.canvas.width, Engine.canvas.height);
      Engine.context.restore();
      Engine.map.render();
      Engine.context.fillStyle = "red";
      Engine.context.font = "bold 12px Arial";
      Engine.context.fillText("fps: " + Engine.fps, Engine.canvasWidth - 100, 15);
      Engine.context.fillText("delta avg: " + Engine.deltaAverage.toFixed(2), Engine.canvasWidth - 100, 30);
    };

    Engine.init = function() {
      var level1, level2;
      level1 = ["###########", "#         #", "#  P      #", "#         #", "#      #  #", "#      #  #", "###    #  #", "#     ##  #", "#         #", "###########"];
      level2 = ["##########", "#        #", "#  ###   #", "#   ##   #", "# P     ##", "#      ###", "##########"];
      Engine.map = new Map(level2);
      Engine.multiplayer = typeof io !== "undefined";
      if (Engine.multiplayer) {
        Engine.socket = io.connect("http://localhost", {
          port: 8000,
          transports: ["websocket"]
        });
      }
      Engine.remotePlayers = [];
      if (Engine.multiplayer) {
        setEventHandlers();
      }
      Engine.run(0);
    };

    Engine.run = function(timestamp) {
      requestAnimationFrame(Engine.run);
      Engine.delta = timestamp - Engine.lastTime;
      Engine.lastTime = timestamp;
      Engine.tick(Engine.delta);
      Engine.render();
      Engine.deltaSum += Engine.delta;
      if (Engine.deltaSum > 1000) {
        Engine.deltaAverage = Engine.deltaSum / Engine.ticks;
        Engine.deltaSum = 0;
        Engine.fps = Engine.ticks;
        Engine.ticks = 0;
      }
    };

    return Engine;

  })();

  $(document).ready(function() {
    var canvasJquery;
    Engine.canvasWidth = 500;
    Engine.canvasHeight = 400;
    canvasJquery = $("<canvas width='" + Engine.canvasWidth + "' height='" + Engine.canvasHeight + "'></canvas>");
    Engine.canvas = canvasJquery.get(0);
    Engine.context = Engine.canvas.getContext("2d");
    canvasJquery.appendTo("body");
    Engine.init();
    $(document).bind("keydown", Engine.input.update);
    $(document).bind("keyup", Engine.input.update);
  });

}).call(this);
